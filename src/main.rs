use std::{collections::HashSet, env};

use futures::TryStreamExt;
use k8s_openapi::{api::discovery::v1::EndpointSlice, Metadata};
use kube::{
	api::{Api, DynamicObject, GroupVersionKind, ObjectMeta, ResourceExt},
	runtime::{watcher, WatchStreamExt},
	Client,
};
use tracing::{debug, error, info, warn};

/// Exclude namespaces that contain NAIS app services we don't care about.
///   Will:
///    - expect comma-separated string lists in environment variable names supplied
///    - remove duplicate namespaces
///    - returns comma-separated string of format `namespace!=<namespace name>`
fn collate_excluded_namespaces(env_vars: &[&str]) -> String {
	let excluded_namespaces: HashSet<String> = env_vars
		.iter()
		.flat_map(|env_var| {
			let Ok(env_val) = env::var(env_var) else {
				warn!("Unable to read supplied env var: {}", env_var);
				return HashSet::new();
			};
			if env_val.is_empty() {
				warn!("Supplied env var was empty: {}", env_var);
				return HashSet::new();
			}
			env_val
				.split(',')
				.map(|ns| format!("namespace!={ns}"))
				.collect()
		})
		.collect();
	excluded_namespaces
		.into_iter()
		.collect::<Vec<_>>()
		.join(",")
}

/// Returns true if and only if at least one of the `EndpointSlice`'s
///  `endpoints[].conditions.ready` evaluate to `true`
///  Always return false elsewise.
fn endpointslice_is_ready(endpoint_slice: &EndpointSlice) -> bool {
	endpoint_slice
		.endpoints
		.iter()
		.flat_map(|e| &e.conditions)
		.filter_map(|c| c.ready)
		.any(|is_ready| is_ready)
}

fn has_expected_owner_reference(o: &ObjectMeta, app_name: &str) -> bool {
	let Some(ref owners) = o.owner_references else {
		// We only care about `EndpointSlice`s that've owner references to a `Service`
		return false;
	};
	owners
		.iter()
		.any(|o| o.api_version == "v1" && o.kind == "Service" && o.name.as_str() == app_name)
}

#[tokio::main]
async fn main() -> color_eyre::eyre::Result<()> {
	tracing_subscriber::fmt::init();

	// We want to filter:
	// - away resources w/o the labels we require
	// - away resources belonging to certain namespaces (TODO)
	let wc = watcher::Config::default().labels("app,team");
	// .fields(&collate_excluded_namespaces(&["PLATFORM_NAMESPACES"]));
	// .streaming_lists(); // TODO: Add back in when cluster supports WatchList feature

	let client = Client::try_default().await?;
	let nais_gvk = GroupVersionKind::gvk("nais.io", "v1alpha1", "Application");
	let (nais_crd, _api_caps) = kube::discovery::pinned_kind(&client, &nais_gvk).await?;

	watcher(Api::<EndpointSlice>::all(client.clone()), wc)
		.applied_objects()
		.default_backoff()
		.try_for_each(|endpoint_slice| {
			// Move these into scope of `.try_for_each()`'s async closure
			let client = client.clone();
			let nais_crd = nais_crd.clone();
			let nais_gvk = nais_gvk.clone();
			async move {
				let endpoint_slice_name = endpoint_slice.name_any();
				let Some(namespace) = endpoint_slice.namespace() else {
					// Something went horribly wrong when we cannot ascertain the namespace
					//   for the given EndpointSlice
					error!("Unable to ascertain namespace of: {}", endpoint_slice_name);
					return Ok(());
				};
				info!("Starting to look at: {}/{}", namespace, endpoint_slice_name);

				let Some(app_name) = endpoint_slice.labels().get("app") else {
					// We expect the team's given app name to be present as this label,
					//  as is customary for things generated by naiserator/NAIS apps
					warn!("Unable to find `app` label on EndpointSlice: {}/{}", namespace, endpoint_slice_name);
					return Ok(());
				};
				let Some(team_name) = endpoint_slice.labels().get("team") else {
					// We expect the team's name to be present as this label,
					//  as is customary for things generated by naiserator/NAIS apps
					warn!("Unable to find `team` label on EndpointSlice: {}/{}", namespace, endpoint_slice_name);
					return Ok(());
				};

				if &namespace != team_name {
					warn!("Label `team_name` (`{}`) does not match namespace: `{}`", team_name, namespace);
					// TODO: Decide if we care enough to do anything about this
				}

				debug!(
					"Checking owner references of {}/{}...",
					&team_name, &app_name
				);
				let has_expected_owner =
					has_expected_owner_reference(endpoint_slice.metadata(), app_name);
				if !has_expected_owner {
					// This is not an endpoint generated for a service, we should not care.
					return Ok(());
				};

				// Ensure owner reference to a nais.io/XXXX Application
				let nais_apps = Api::<DynamicObject>::namespaced_with(client, &namespace, &nais_crd);
				match nais_apps.get_opt(app_name).await {
					Err(e) => {
						error!("Error occurred when attempting to fetch `{}/{} {}` from namespace `{}`: {}", &nais_gvk.group, &nais_gvk.version, &nais_gvk.kind, &namespace, e);
						// return Err(e); // TODO: Fix this so backoff can handle it
						return Ok(());
					},
					Ok(nais_app) => {
						let Some(_) = nais_app else {
							warn!(
								"Unable to find a `{}/{} {}` in namespace {}",
								&nais_gvk.group, &nais_gvk.version, &nais_gvk.kind, &namespace
							);
							return Ok(());
						};
					},
				};

				info!("Ascertained that this EndpointSlice seems to be a product of a NAIS app: {}/{} -> {}/{}", namespace, &app_name, namespace, endpoint_slice_name);
				if endpointslice_is_ready(&endpoint_slice) {
					warn!(
						"{}/{} is alive!!!",
						endpoint_slice.metadata.namespace.unwrap(),
						endpoint_slice.metadata.name.unwrap()
					);
				} else {
					warn!(
						"{}/{} is dead!!!",
						endpoint_slice.metadata.namespace.unwrap(),
						endpoint_slice.metadata.name.unwrap()
					);
				}
				// TODO: Send http request to the statusplattform backend API w/reqwest
				todo!();
				// Ok(()) // TODO: Comment back in when removing above todo!()
			}
		})
		.await?;
	Ok(())
}
